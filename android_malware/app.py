from flask import Flask,render_template,request
import numpy as np
import pandas as pd
import joblib
from androguard.misc import AnalyzeAPK


df_new_cols=['SEND_SMS','READ_PHONE_STATE','GET_ACCOUNTS','RECEIVE_SMS','READ_SMS',
'USE_CREDENTIALS','MANAGE_ACCOUNTS','WRITE_SMS','READ_SYNC_SETTINGS','AUTHENTICATE_ACCOUNTS', 'WRITE_HISTORY_BOOKMARKS', 'INSTALL_PACKAGES',
'CAMERA' ,'WRITE_SYNC_SETTINGS', 'READ_HISTORY_BOOKMARKS', 'INTERNET', 'RECORD_AUDIO', 'NFC', 'ACCESS_LOCATION_EXTRA_COMMANDS',
'WRITE_APN_SETTINGS', 'BIND_REMOTEVIEWS', 'READ_PROFILE', 'MODIFY_AUDIO_SETTINGS', 'READ_SYNC_STATS', 'BROADCAST_STICKY', 'WAKE_LOCK',
'RECEIVE_BOOT_COMPLETED', 'RESTART_PACKAGES', 'BLUETOOTH', 'READ_CALENDAR', 'READ_CALL_LOG', 'SUBSCRIBED_FEEDS_WRITE',
'READ_EXTERNAL_STORAGE', 'VIBRATE', 'ACCESS_NETWORK_STATE', 'SUBSCRIBED_FEEDS_READ', 'CHANGE_WIFI_MULTICAST_STATE',
'WRITE_CALENDAR', 'MASTER_CLEAR','UPDATE_DEVICE_STATS', 'WRITE_CALL_LOG' ,'DELETE_PACKAGES', 'GET_TASKS', 'GLOBAL_SEARCH',
'DELETE_CACHE_FILES', 'WRITE_USER_DICTIONARY','REORDER_TASKS','WRITE_PROFILE', 'SET_WALLPAPER', 'BIND_INPUT_METHOD',
 'READ_SOCIAL_STREAM', 'READ_USER_DICTIONARY', 'PROCESS_OUTGOING_CALLS', 'CALL_PRIVILEGED','BIND_WALLPAPER', 'RECEIVE_WAP_PUSH',
'DUMP', 'BATTERY_STATS', 'ACCESS_COARSE_LOCATION', 'SET_TIME', 'WRITE_SOCIAL_STREAM', 'WRITE_SETTINGS', 'REBOOT',
 'BLUETOOTH_ADMIN', 'BIND_DEVICE_ADMIN','WRITE_GSERVICES','KILL_BACKGROUND_PROCESSES','STATUS_BAR','PERSISTENT_ACTIVITY','CHANGE_NETWORK_STATE',
 'RECEIVE_MMS','SET_TIME_ZONE','CONTROL_LOCATION_UPDATES','BROADCAST_WAP_PUSH','BIND_ACCESSIBILITY_SERVICE','ADD_VOICEMAIL','CALL_PHONE','BIND_APPWIDGET',
 'FLASHLIGHT','READ_LOGS','SET_PROCESS_LIMIT','MOUNT_UNMOUNT_FILESYSTEMS','BIND_TEXT_SERVICE','INSTALL_LOCATION_PROVIDER',
 'SYSTEM_ALERT_WINDOW','MOUNT_FORMAT_FILESYSTEMS','CHANGE_CONFIGURATION','CLEAR_APP_USER_DATA','CHANGE_WIFI_STATE','READ_FRAME_BUFFER',
 'ACCESS_SURFACE_FLINGER','BROADCAST_SMS','EXPAND_STATUS_BAR','INTERNAL_SYSTEM_WINDOW','SET_ACTIVITY_WATCHER','WRITE_CONTACTS',
 'BIND_VPN_SERVICE','DISABLE_KEYGUARD','ACCESS_MOCK_LOCATION','GET_PACKAGE_SIZE','MODIFY_PHONE_STATE','CHANGE_COMPONENT_ENABLED_STATE',
 'CLEAR_APP_CACHE','SET_ORIENTATION','READ_CONTACTS','DEVICE_POWER','HARDWARE_TEST','ACCESS_WIFI_STATE','WRITE_EXTERNAL_STORAGE',
 'ACCESS_FINE_LOCATION','SET_WALLPAPER_HINTS','SET_PREFERRED_APPLICATIONS','WRITE_SECURE_SETTINGS', 'android.intent.action.BOOT_COMPLETED',
 'android.intent.action.SEND', 'android.intent.action.PACKAGE_REPLACED', 'android.intent.action.SEND_MULTIPLE', 'android.intent.action.TIME_SET', 'android.intent.action.PACKAGE_REMOVED', 'android.intent.action.TIMEZONE_CHANGED',
 'android.intent.action.ACTION_POWER_DISCONNECTED', 'android.intent.action.PACKAGE_ADDED', 'android.intent.action.ACTION_SHUTDOWN', 'android.intent.action.PACKAGE_DATA_CLEARED', 'android.intent.action.PACKAGE_CHANGED',
 'android.intent.action.NEW_OUTGOING_CALL', 'android.intent.action.SENDTO', 'android.intent.action.CALL', 'android.intent.action.SCREEN_ON', 'android.intent.action.BATTERY_OKAY', 'android.intent.action.PACKAGE_RESTARTED',
 'android.intent.action.CALL_BUTTON', 'android.intent.action.SCREEN_OFF', 'android.intent.action.SET_WALLPAPER', 'android.intent.action.BATTERY_LOW', 'android.intent.action.ACTION_POWER_CONNECTED']

model = joblib.load('model')


UPLOAD_FOLDER="E:\codes\work\android_malware"


app=Flask(__name__)
app.config['UPLOAD_FOLDER']=UPLOAD_FOLDER

@app.route('/')
def home():
    return render_template('home.html')

@app.route('/predict',methods=['POST'])
def predict():
    if request.method=='POST':
        f=request.files['file']
        f.save(f.filename)
        if f:
            new_apks_df=[]  #we are creating lists of list
            a,d,dx=AnalyzeAPK(f.filename)  # using AnalyzeAPK module
            permissions=a.get_permissions()  #get all the list of permission
            apk_features=[]

           # for permissions
            for i in permissions:  #iterate over the permissions to get the ones starting with android.permission
              if i.startswith("android.permission"):  #if starts with android.permission then only split and append it
                apk_features.append(i.split("android.permission.",1)[1])

           #for intent
            intents=[]
            receivers= a.get_receivers()  #since the features in the dataset are only for receivers

            for receiver in receivers:  #iterate over receivers to get it's intent

                for action,intent_name in a.get_intent_filters('receiver', receiver).items():  #loop over the objects we get in get_intent_filters

                    for intent in intent_name:  #for all the intent we get simply append it
                        intents.append(intent)
            for i in intents:  # now for all the intent appended
                if i.startswith("android.intent.action"):  #if it starts with android.intent.action then append it into the list of the features
                    apk_features.append(i)

            apk_df=[]
            for i in df_new_cols:  #now check if this features exist in our original features
                if i in apk_features:#if it exists then append 1 else append 0
                    apk_df.append(1)
                else:
                    apk_df.append(0)
            new_apks_df.append(apk_df)  #append the list to original list to create lists of list
            apk_df2= pd.DataFrame(new_apks_df,columns=df_new_cols) # pass this into pd.DataFrame to create  dataframe and drop class since we have no use for it while predicting



        prediction = model.predict(apk_df2)



    return render_template('result.html',pred = prediction)






if __name__=='__main__':
    app.run(debug=True)
